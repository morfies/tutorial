原文链接： 
[https://medium.freecodecamp.org/do-you-want-a-better-understanding-of-buffer-in-node-js-check-this-out-2e29de2968e8](https://medium.freecodecamp.org/do-you-want-a-better-understanding-of-buffer-in-node-js-check-this-out-2e29de2968e8)

Buffer: 此Class被作为Node.js API是用来操纵或者交互二进制流
首先，何为二进制？
即一系列0和1的序列组合，计算机只能理解二进制
常见的数值类型能很方便的通过数学方法转换为二进制，但我们还有其它类型，诸如strings、images、videos
计算机都能将这些类型的数据转换为二进制

让我们以string “L”为例，为了以二进制的方式存储任何字符，计算机会首先将字符转换为数值，然后将此数值转换为二进制表现形式；对于“L”，我们来看怎么转换为数值先：
> 打开浏览器控制台，输入以下代码，回车，看看结果 
> "L".charCodeAt(0) 
> 返回数值76，这就是L的数值或者字符编码(Character Code)或者码点(Code Point)了。

那么计算机怎么知道具体由那个数值代表某字符呢？

\*字符集\*
字符集是预先定义好的字符和数字间的映射关系。常见的有Unicode和ASCII。
我们已经知道了计算机是怎么用数字来表示字符的了，那么接下来计算机只需将76转换为二进制表示了，也许你会想，这不就是将76转换为2为基数的数值表示么，别着急

\*字符编码\*
字符集定义了由什么数字表示字符，但是还需要有规则来定义这些数字应该具体怎么样组织成二进制编码，即，具体使用多少bit来表示一个数字。这就是字符编码
其中一种字符编码叫UTF-8。UTF-8规定字符串应该以字节为单位来表示，即8个bit用来表示字符的CodePoint的二进制形式。

进一步理解，比如12的二进制形式是1100， 于是UTF-8中，12应该占据8bit，于是12的最终表示序列为00001100.
因此，76会被存储为01001100.

这就是计算机怎么用二进制存储string和字符了。同理，计算机也有相应的规则规定image和video应怎么转换。这几的重点是，计算机存储所有类型的数据在二进制序列中，即binary data。

\*二进制流 Stream\*
Stream在Node.js中仅仅意味着一系列的数据在一段时间内从一个地方移动到另一个地方。整体概念是，你有大量的数据需要处理，但是不需要等到所有数据都接收完后才开始处理。
从本质来说，大数据被切分了，并以数据块(chunk)的方式发送。那么Buffer在Streaming过程中到底是怎么帮助我们操纵和处理二进制的呢？

\*Buffer\*
我们已经了解到数据流(a stream of data)是指一段时间内将数据从一个点移动到另一个点的活动，但具体是怎么移动的呢？

通常的，数据的传输意味着需要处理它们，或者读取然后做决策等。但是一个进程在规定时间内处理数据的能力是有上下限的，因此，如果接受数据的速度大于处理速度，则多余接受到的数据就需要在某个地方等待被处理。
另一方面，如果处理速度大于接受速度，先到的少量数据又需要等待足够的数据后，才被一起分配去处理。

这个“等待区”就是Buffer了。Buffer是一块小的物理存储空间(通常在RAM中)，在streaming的过程中，数据在这里暂时集结，等待最终被分配处理。

我们可以用公交站来类比stream和buffer的过程，在某些公交站，公汽只有在乘客达到一定数量或者等待一定时间之后才能离站。而乘客则以不同的速度和不同的时间来到站台。在任何情况下，乘客如果来早了，就需要等待知道公汽决定上路，而如果乘客来晚了，则只能等下一趟公汽出发。

不管何种情况，总会有个等待区，这在Node.js中就是Buffer了，Node.js不能控制数据到达的时间和速度(stream速度)，而只能决定何时将数据发出处理。如果时机未到，将数据存入Buffer，直到合适时间发出这些数据去处理。

同样的可以用视频流做对比，你在线观看视频，视频网站会先获取一批数据，在你观看这部分数据的同时，后台继续获取下一批数据，当你上一部分观看完毕，而下一批还没取完，则会出现“加载中。。。”的字样，等到取到完整的下一批数据后，播放器有开始播放，如此循环，直到整个stream完毕。

从Buffer的原始定义来看，我们是能够在streaming的过程中，操纵buffer中的原始数据的，Node.js的Buffer实现给我们提供了一些API。




